<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HectoClash Game</title>
  <style>
    :root {
      --dark-bg: #0d0d0d;
      --blue-primary: #1e90ff;
      --blue-accent: #00aaff;
      --neon-blue: #00ccff;
      --light-text: #e0e0e0;
      --card-bg: rgba(20, 20, 20, 0.95);
      --btn-bg: #1e90ff;
      --btn-hover: #00aaff;
      --border: #333;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      background: linear-gradient(135deg, #0d0d0d 0%, #1a1a1a 100%);
      color: var(--light-text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .animated-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(0, 204, 255, 0.15), transparent 70%);
      animation: pulse 5s infinite;
      z-index: -1;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }
    .container {
      max-width: 900px;
      width: 100%;
      padding: 2rem;
      background: var(--card-bg);
      border-radius: 15px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      border: 1px solid var(--border);
      margin: 1rem;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 0;
      margin-bottom: 1.5rem;
    }
    .player {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .player img {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid var(--blue-primary);
    }
    .timer {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--neon-blue);
      min-width: 80px;
      text-align: center;
    }
    .score {
      font-size: 1.2rem;
      font-weight: bold;
      color: var(--blue-accent);
      margin: 1rem 0;
      text-align: center;
    }
    .question {
      font-size: 2rem;
      margin: 2rem 0;
      padding: 1rem;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      color: var(--neon-blue);
      letter-spacing: 2px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .input-area {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    input[type="text"] {
      padding: 12px 16px;
      font-size: 1rem;
      width: 100%;
      background: rgba(30,30,30,0.8);
      border: 1px solid var(--border);
      color: var(--light-text);
      border-radius: 8px;
      transition: border-color 0.3s ease;
      pointer-events: none;
    }
    .button-container {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 1rem 0;
    }
    .num-btn, .operator-btn {
      padding: 12px 20px;
      font-size: 1.2rem;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      transition: all 0.3s ease;
    }
    .num-btn {
      background: var(--blue-primary);
      color: white;
    }
    .operator-btn {
      background: var(--neon-blue);
      color: var(--dark-bg);
    }
    .num-btn:hover:not(:disabled) {
      background: var(--btn-hover);
      transform: translateY(-2px);
    }
    .operator-btn:hover {
      background: #00aaff;
      transform: translateY(-2px);
    }
    @media (max-width: 768px) {
      .container { padding: 1rem; }
      .header { flex-direction: column; gap: 1rem; }
      .question { font-size: 1.5rem; }
      .input-area { flex-direction: column; align-items: center; }
    }
    .math-symbol {
      position: absolute;
      font-size: 2rem;
      color: var(--blue-accent);
      animation: float 10s infinite ease-in-out;
      opacity: 0.6;
    }
    @keyframes float {
      0% {
        transform: translateY(100vh) rotate(0deg);
      }
      100% {
        transform: translateY(-100vh) rotate(360deg);
      }
    }
    .butn {
      background-color: black;
      color: white;
      padding: 10px 20px;
      font-size: 1rem;
      border: 2px solid;
      border-image: linear-gradient(to right, blue, white) 1;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    .butn:hover {
      background-color: #111;
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(0, 0, 255, 0.5);
    }
    .math-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      z-index: -1;
    }
  </style>
</head>
<body>
  <div class="animated-bg"></div>
  <div class="math-bg" id="math-bg"></div>
  <div class="container">
    <div class="header">
      <!-- Static names: "You" and "Opponent" -->
      <div class="player" id="player1">
        <span id="p1name">You</span>
      </div>
      <div class="timer" id="timer">03:00</div>
      <div class="player" id="player2">
        <span id="p2name">Opponent</span>
        <div class="score" id="opponentScore">Score: 0</div>
      </div>
    </div>
    <div class="score">Score: <span id="score">0</span></div>
    <div class="question" id="question"></div>
    <div class="input-area">
      <input type="text" id="answerInput" placeholder="Build your equation" readonly />
    </div>
    <div class="button-container" id="operatorButtons">
      <button class="operator-btn" data-operator="+">+</button>
      <button class="operator-btn" data-operator="-">-</button>
      <button class="operator-btn" data-operator="*">×</button>
      <button class="operator-btn" data-operator="/">÷</button>
      <button class="operator-btn" data-operator="(">(</button>
      <button class="operator-btn" data-operator=")">)</button>
      <button class="operator-btn" data-operator="^">^</button>
      <button class="operator-btn" id="backspace">⌫</button>
    </div>
    <div class="input-area">
      <button id="submit" class="btn">Submit</button>
      <button id="skip" class="butn">Skip</button>
    </div>
  </div>

  <script type="module">
    // Import Firebase modules from the modular SDK
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.0/firebase-auth.js';
    import {
      getFirestore,
      doc,
      collection,
      query,
      where,
      getDocs,
      onSnapshot,
      runTransaction,
      getDoc,
      updateDoc
    } from 'https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyBF5w8l2TiH1OTFho-N4qBlVzgC5fw8dG4",
      authDomain: "techsprint-53b5c.firebaseapp.com",
      projectId: "techsprint-53b5c",
      storageBucket: "techsprint-53b5c.appspot.com",
      messagingSenderId: "366810852442",
      appId: "1:366810852442:web:d31260159a6c8b1c307c63",
      measurementId: "G-PTPH19Z3QG"
    };

    // Initialize Firebase app, auth, and Firestore using modular API
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let uid = null;
    let score = 0;
    let questionIndex = 0;
    let gameId = localStorage.getItem("gameId");
    let cor = 0, incor = 0, sk = 0;
    let timerInterval;
    let questionList = [];
    // Stack to track used number buttons
    let usedButtonsStack = [];

    const questionBox = document.getElementById("question");
    const scoreBox = document.getElementById("score");

    // Create number buttons from the given array. Each button can only be used once.
    function createNumberButtons(numbers) {
      questionBox.innerHTML = '';
      // Clear any previously used buttons
      usedButtonsStack = [];
      numbers.forEach((num, index) => {
        const btn = document.createElement('button');
        btn.className = 'num-btn';
        btn.textContent = num;
        // Save a unique id for each button based on index
        btn.dataset.idx = index;
        btn.addEventListener('click', () => {
          // Append number and disable the button
          document.getElementById("answerInput").value += num;
          btn.disabled = true;
          usedButtonsStack.push(btn);
        });
        questionBox.appendChild(btn);
      });
    }

    // Operator buttons append their operator (they are reusable)
    document.querySelectorAll('.operator-btn').forEach(btn => {
      if(btn.id !== 'backspace') {
        btn.addEventListener('click', () => {
          document.getElementById("answerInput").value += btn.dataset.operator;
        });
      }
    });

    // Backspace: remove the last character.
    // If the removed character was a digit coming from a number button, re-enable that button.
    document.getElementById("backspace").addEventListener('click', () => {
      const input = document.getElementById("answerInput");
      if (input.value.length === 0) return;
      const lastChar = input.value.slice(-1);
      // Check if the last character is a digit (number buttons produce single-digit numbers)
      if (/\d/.test(lastChar) && usedButtonsStack.length > 0) {
        // Re-enable the last used number button
        const btn = usedButtonsStack.pop();
        btn.disabled = false;
      }
      input.value = input.value.slice(0, -1);
    });

    // Prevent manual input into the answer field
    document.getElementById("answerInput").addEventListener('keydown', (e) => {
      e.preventDefault();
    });

    // Animated math background symbols
    const symbols = ['+', '-', '\u00D7', '\u00F7', '=', '\u221A', '\u03C0', '\u222B'];
    const container = document.getElementById('math-bg');
    for (let i = 0; i < 100; i++) {
      const symbol = document.createElement('div');
      symbol.classList.add('math-symbol');
      symbol.textContent = symbols[Math.floor(Math.random() * symbols.length)];
      symbol.style.left = Math.random() * 100 + 'vw';
      symbol.style.top = Math.random() * 100 + 'vh';
      symbol.style.fontSize = Math.random() * 3 + 1 + 'rem';
      symbol.style.animationDuration = (5 + Math.random() * 10) + 's';
      container.appendChild(symbol);
    }
      
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        uid = user.uid;
        // Using static names: "You" and "Opponent", so we do not update based on user data

        const gameRef = doc(db, "matchmaking", gameId);
        const gameSnap = await getDoc(gameRef);
        let gameData = gameSnap.data();

        if (!gameData.questions) {
          const questions = {};
          for (let i = 1; i <= 10; i++) {
            questions[`q${i}`] = await generateValidQuestion();
          }
          // Update the game document with generated questions
          await updateDoc(gameRef, { questions });
          gameData = { ...gameData, questions };
        }

        // Determine opponent UID without fetching name (only used for score updates)
        let opponentUid;
        if (gameData.player1 === uid) {
          opponentUid = gameData.player2;
        } else {
          opponentUid = gameData.player1;
        }
        
        // Listen for game document changes to update opponent's score dynamically
        onSnapshot(gameRef, (docSnapshot) => {
          const gameData = docSnapshot.data();
          const isPlayer1 = gameData.player1 === uid;
          const opponentData = isPlayer1 ? gameData.p2 : gameData.p1;
          if (opponentData) {
            document.getElementById("opponentScore").textContent = `Score: ${opponentData[0]}`;
          }
        });

        // Ensure that the questions array only includes valid arrays (length 6)
        questionList = Object.values(gameData.questions)
          .slice(0, 10)
          .filter(q => Array.isArray(q) && q.length === 6);

        startGame();
      }
    });

    // Fetch a valid question: an array of 6 single-digit numbers.
    async function generateValidQuestion() {
      try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyA4c9l0IieSxZXoX9ehc1zX0aMBBH-MuAs`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: "Generate an array of 6 single-digit numbers (1-9) that can form 100 using standard arithmetic operations. Respond ONLY with the array in JSON format like [1,2,3,4,5,6] with no additional text."
              }]
            }]
          })
        });
        const data = await response.json();
        const numbers = JSON.parse(data.candidates[0].content.parts[0].text);
        return numbers.filter(n => n >= 1 && n <= 9);
      } catch (error) {
        return [1, 2, 3, 4, 5, 6];
      }
    }

    function startGame() {
      createNumberButtons(questionList[questionIndex]);
      startTimer(180);
    }

    document.getElementById("submit").addEventListener("click", submitAnswer);
    document.getElementById("skip").addEventListener("click", skipQuestion);

    async function submitAnswer() {
      const input = document.getElementById("answerInput").value.trim();
      if (!input) return;
      
      try {
        const expression = input.replace(/ /g, '');
        const result = eval(expression);
        if (Math.abs(result - 100) < 1e-6) {
          cor++;
          score += 5;
        } else {
          incor++;
          score -= 3;
        }
      } catch {
        incor++;
        score -= 3;
      }
      scoreBox.textContent = score;
      await nextQuestion();
    }

    async function skipQuestion() {
      sk++;
      score -= 1;
      scoreBox.textContent = score;
      await nextQuestion();
    }

    async function nextQuestion() {
      document.getElementById("answerInput").value = "";
      questionIndex++;
      if (questionIndex >= questionList.length) {
        await endGame();
      } else {
        createNumberButtons(questionList[questionIndex]);
      }
    }

    function startTimer(duration) {
      let time = duration;
      const timerDisplay = document.getElementById("timer");
      timerInterval = setInterval(() => {
        let minutes = Math.floor(time / 60);
        let seconds = time % 60;
        timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        if (--time < 0) {
          clearInterval(timerInterval);
          endGame();
        }
      }, 1000);
    }

    async function endGame() {
      clearInterval(timerInterval);
      
      const gameRef = doc(db, "matchmaking", gameId);
      
      try {
        await runTransaction(db, async (transaction) => {
          const gameDoc = await transaction.get(gameRef);
          if (!gameDoc.exists()) {
            throw "Document does not exist!";
          }
          const gameData = gameDoc.data();
          const isPlayer1 = gameData.player1 === uid;
          
          // Merge updates: if current player's data is available, update it,
          // otherwise, keep the existing data for the opponent.
          const updatedP1 = isPlayer1 ? [score, cor, incor, sk] : (gameData.p1 || [0, 0, 0, 0]);
          const updatedP2 = !isPlayer1 ? [score, cor, incor, sk] : (gameData.p2 || [0, 0, 0, 0]);
          
          transaction.update(gameRef, {
            p1: updatedP1,
            p2: updatedP2
          });
        });
      } catch (e) {
        console.error("Transaction failed: ", e);
      }

      // Update user stats in their document (if needed)
      const playerRef = doc(db, "users", auth.currentUser.email);
      const playerSnap = await getDoc(playerRef);
      const playerData = playerSnap.data();
      
      await updateDoc(playerRef, {
        num: (playerData.num || 0) + 1,
        game_id: gameId
      });

      // After updating the game doc, retrieve final scores and store in local storage.
      const updatedGameSnap = await getDoc(gameRef);
      const updatedGameData = updatedGameSnap.data();
      const isPlayer1 = updatedGameData.player1 === uid;
      let finalUserScore, finalOpponentScore;
      if (isPlayer1) {
        finalUserScore = updatedGameData.p1 ? updatedGameData.p1[0] : score;
        finalOpponentScore = updatedGameData.p2 ? updatedGameData.p2[0] : 0;
      } else {
        finalUserScore = updatedGameData.p2 ? updatedGameData.p2[0] : score;
        finalOpponentScore = updatedGameData.p1 ? updatedGameData.p1[0] : 0;
      }
      localStorage.setItem('finalScores', JSON.stringify({ user: finalUserScore, opponent: finalOpponentScore }));

      window.location.href = "result.html";
    }
  </script>
</body>
</html>
